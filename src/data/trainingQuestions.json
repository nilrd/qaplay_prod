[
  {
    "id": 1,
    "question": "Segundo o CTFL 4.0, qual é o objetivo principal do teste de software?",
    "options": [
      "Provar que o software não tem defeitos",
      "Encontrar todos os defeitos possíveis",
      "Reduzir o risco de falhas em produção e fornecer informações sobre qualidade",
      "Acelerar o processo de desenvolvimento"
    ],
    "correct": 2,
    "explanation": "O objetivo principal do teste é reduzir o risco de falhas em produção e fornecer informações sobre a qualidade do software para os stakeholders tomarem decisões informadas."
  },
  {
    "id": 2,
    "question": "Qual dos seguintes NÃO é um princípio fundamental de teste segundo o CTFL 4.0?",
    "options": [
      "Teste mostra a presença de defeitos, não sua ausência",
      "Teste deve começar o mais cedo possível",
      "Teste exaustivo é impossível",
      "Defeitos se agrupam"
    ],
    "correct": 1,
    "explanation": "O teste deve começar o mais cedo possível (shift-left), não o mais tarde possível. Testar cedo reduz custos e melhora a qualidade."
  },
  {
    "id": 3,
    "question": "O que significa 'shift-left' no contexto de testes?",
    "options": [
      "Mover testes para o lado esquerdo da tela",
      "Mover atividades de teste para fases anteriores do ciclo de vida",
      "Reduzir o número de testes",
      "Focar apenas em testes automatizados"
    ],
    "correct": 1,
    "explanation": "Shift-left significa mover atividades de teste para fases anteriores do ciclo de desenvolvimento, permitindo detecção precoce de defeitos."
  },
  {
    "id": 4,
    "question": "Qual é a diferença entre verificação e validação?",
    "options": [
      "São sinônimos",
      "Verificação: 'estamos construindo certo?', Validação: 'estamos construindo a coisa certa?'",
      "Verificação é manual, validação é automatizada",
      "Verificação é para código, validação é para documentos"
    ],
    "correct": 1,
    "explanation": "Verificação pergunta 'estamos construindo o produto certo?' (conforme especificações), enquanto validação pergunta 'estamos construindo o produto certo?' (atende necessidades do usuário)."
  },
  {
    "id": 5,
    "question": "No modelo V, qual fase de teste corresponde aos requisitos de sistema?",
    "options": [
      "Teste de unidade",
      "Teste de integração",
      "Teste de sistema",
      "Teste de aceitação"
    ],
    "correct": 2,
    "explanation": "No modelo V, o teste de sistema corresponde aos requisitos de sistema, verificando se o sistema completo atende aos requisitos especificados."
  },
  {
    "id": 6,
    "question": "Qual é o foco principal dos testes de unidade?",
    "options": [
      "Testar a interface do usuário",
      "Testar componentes individuais isoladamente",
      "Testar a integração entre sistemas",
      "Testar requisitos de negócio"
    ],
    "correct": 1,
    "explanation": "Testes de unidade focam em testar componentes individuais (funções, métodos, classes) isoladamente para verificar se funcionam conforme especificado."
  },
  {
    "id": 7,
    "question": "O que caracteriza o teste de integração big-bang?",
    "options": [
      "Integração gradual de componentes",
      "Integração de todos os componentes simultaneamente",
      "Teste apenas de interfaces",
      "Teste de performance"
    ],
    "correct": 1,
    "explanation": "No teste de integração big-bang, todos os componentes são integrados simultaneamente e testados como um todo, ao contrário da integração incremental."
  },
  {
    "id": 8,
    "question": "Qual é a vantagem da integração incremental sobre big-bang?",
    "options": [
      "É mais rápida",
      "Facilita a localização de defeitos",
      "Requer menos recursos",
      "É mais simples de implementar"
    ],
    "correct": 1,
    "explanation": "A integração incremental facilita a localização de defeitos, pois quando um problema é encontrado, é mais fácil identificar qual componente ou interface está causando o problema."
  },
  {
    "id": 9,
    "question": "O que são testes de aceitação do usuário (UAT)?",
    "options": [
      "Testes técnicos realizados por desenvolvedores",
      "Testes realizados por usuários finais para validar se o sistema atende suas necessidades",
      "Testes de performance",
      "Testes de segurança"
    ],
    "correct": 1,
    "explanation": "UAT são testes realizados por usuários finais ou seus representantes para validar se o sistema atende às necessidades de negócio e está pronto para uso."
  },
  {
    "id": 10,
    "question": "Qual é a diferença entre teste funcional e não-funcional?",
    "options": [
      "Funcional testa 'o que' o sistema faz, não-funcional testa 'como' o sistema se comporta",
      "Funcional é automatizado, não-funcional é manual",
      "Funcional é para desenvolvedores, não-funcional é para usuários",
      "Não há diferença significativa"
    ],
    "correct": 0,
    "explanation": "Teste funcional verifica 'o que' o sistema faz (funcionalidades), enquanto teste não-funcional verifica 'como' o sistema se comporta (performance, usabilidade, segurança)."
  },
  {
    "id": 11,
    "question": "Qual técnica de teste de caixa preta é baseada na divisão de dados de entrada em grupos equivalentes?",
    "options": [
      "Análise de valor limite",
      "Particionamento de equivalência",
      "Tabela de decisão",
      "Teste de transição de estado"
    ],
    "correct": 1,
    "explanation": "Particionamento de equivalência divide dados de entrada em grupos (partições) onde todos os valores devem ser tratados de forma similar pelo sistema."
  },
  {
    "id": 12,
    "question": "Por que a análise de valor limite é importante?",
    "options": [
      "Testa apenas valores válidos",
      "Defeitos tendem a ocorrer nos limites das partições",
      "É mais rápida que outras técnicas",
      "Não requer conhecimento do sistema"
    ],
    "correct": 1,
    "explanation": "A análise de valor limite é importante porque defeitos tendem a ocorrer nos limites das partições equivalentes, onde a lógica de validação pode falhar."
  },
  {
    "id": 13,
    "question": "Quando usar tabelas de decisão para teste?",
    "options": [
      "Para testar performance",
      "Quando há múltiplas condições e combinações de regras de negócio",
      "Apenas para testes automatizados",
      "Para testar interfaces gráficas"
    ],
    "correct": 1,
    "explanation": "Tabelas de decisão são úteis quando há múltiplas condições de entrada e diferentes combinações resultam em diferentes ações ou resultados."
  },
  {
    "id": 14,
    "question": "O que é cobertura de declaração (statement coverage)?",
    "options": [
      "Percentual de requisitos cobertos",
      "Percentual de linhas de código executadas",
      "Percentual de casos de teste executados",
      "Percentual de defeitos encontrados"
    ],
    "correct": 1,
    "explanation": "Cobertura de declaração mede o percentual de linhas de código (declarações) que foram executadas durante os testes."
  },
  {
    "id": 15,
    "question": "Por que 100% de cobertura de código não garante ausência de defeitos?",
    "options": [
      "Porque é impossível alcançar 100%",
      "Porque não testa todas as combinações possíveis de dados",
      "Porque só funciona para código simples",
      "Porque é muito caro"
    ],
    "correct": 1,
    "explanation": "100% de cobertura de código não garante ausência de defeitos porque não testa todas as combinações possíveis de dados de entrada e condições."
  },
  {
    "id": 16,
    "question": "Qual é a diferença entre cobertura de declaração e cobertura de decisão?",
    "options": [
      "São a mesma coisa",
      "Declaração mede linhas executadas, decisão mede caminhos de decisão exercitados",
      "Declaração é para código, decisão é para requisitos",
      "Declaração é manual, decisão é automatizada"
    ],
    "correct": 1,
    "explanation": "Cobertura de declaração mede linhas de código executadas, enquanto cobertura de decisão mede se todos os caminhos de decisão (verdadeiro/falso) foram exercitados."
  },
  {
    "id": 17,
    "question": "O que é um caso de teste?",
    "options": [
      "Um defeito encontrado",
      "Um conjunto de pré-condições, dados de entrada e resultados esperados",
      "Uma ferramenta de automação",
      "Um ambiente de teste"
    ],
    "correct": 1,
    "explanation": "Um caso de teste é um conjunto de pré-condições, dados de entrada, ações de execução e resultados esperados desenvolvido para um objetivo específico."
  },
  {
    "id": 18,
    "question": "Qual informação NÃO é essencial em um caso de teste?",
    "options": [
      "Pré-condições",
      "Dados de entrada",
      "Nome do testador que criou",
      "Resultado esperado"
    ],
    "correct": 2,
    "explanation": "O nome do testador que criou o caso de teste não é essencial para sua execução, ao contrário das pré-condições, dados de entrada e resultado esperado."
  },
  {
    "id": 19,
    "question": "O que é rastreabilidade em testes?",
    "options": [
      "Velocidade de execução",
      "Capacidade de rastrear relacionamentos entre requisitos, casos de teste e defeitos",
      "Localização geográfica dos testes",
      "Histórico de execuções"
    ],
    "correct": 1,
    "explanation": "Rastreabilidade é a capacidade de rastrear relacionamentos bidirecionais entre requisitos, casos de teste, execuções e defeitos."
  },
  {
    "id": 20,
    "question": "Por que a rastreabilidade é importante?",
    "options": [
      "Para acelerar os testes",
      "Para garantir cobertura de requisitos e facilitar análise de impacto",
      "Para reduzir custos",
      "Para automatizar testes"
    ],
    "correct": 1,
    "explanation": "Rastreabilidade é importante para garantir que todos os requisitos são cobertos por testes e facilitar análise de impacto quando há mudanças."
  },
  {
    "id": 21,
    "question": "O que caracteriza um bom relatório de defeito?",
    "options": [
      "Ser o mais curto possível",
      "Conter informações claras, precisas e suficientes para reprodução",
      "Incluir apenas a severidade",
      "Ser escrito em linguagem técnica complexa"
    ],
    "correct": 1,
    "explanation": "Um bom relatório de defeito deve conter informações claras, precisas e suficientes para que outros possam entender e reproduzir o problema."
  },
  {
    "id": 22,
    "question": "Qual é a diferença entre severidade e prioridade de um defeito?",
    "options": [
      "São sinônimos",
      "Severidade é o impacto técnico, prioridade é a urgência de correção",
      "Severidade é para desenvolvedores, prioridade é para testadores",
      "Severidade é subjetiva, prioridade é objetiva"
    ],
    "correct": 1,
    "explanation": "Severidade refere-se ao impacto técnico do defeito no sistema, enquanto prioridade refere-se à urgência de correção do ponto de vista de negócio."
  },
  {
    "id": 23,
    "question": "Um defeito pode ter alta severidade e baixa prioridade?",
    "options": [
      "Não, severidade e prioridade sempre coincidem",
      "Sim, por exemplo, um crash em funcionalidade raramente usada",
      "Apenas em sistemas legados",
      "Apenas durante desenvolvimento"
    ],
    "correct": 1,
    "explanation": "Sim, um defeito pode ter alta severidade (grande impacto técnico) mas baixa prioridade (não urgente), como um crash em uma funcionalidade raramente usada."
  },
  {
    "id": 24,
    "question": "O que é teste de regressão?",
    "options": [
      "Teste de funcionalidades novas",
      "Teste para verificar se mudanças não afetaram funcionalidades existentes",
      "Teste de performance",
      "Teste de usabilidade"
    ],
    "correct": 1,
    "explanation": "Teste de regressão verifica se mudanças no software (correções, melhorias, novas funcionalidades) não introduziram novos defeitos em funcionalidades já testadas."
  },
  {
    "id": 25,
    "question": "Quando executar testes de regressão?",
    "options": [
      "Apenas no final do projeto",
      "Após qualquer mudança no software",
      "Apenas para defeitos críticos",
      "Apenas em ambiente de produção"
    ],
    "correct": 1,
    "explanation": "Testes de regressão devem ser executados após qualquer mudança no software para garantir que funcionalidades existentes não foram afetadas."
  },
  {
    "id": 26,
    "question": "O que é automação de testes?",
    "options": [
      "Execução manual mais rápida",
      "Uso de ferramentas para executar testes sem intervenção manual",
      "Teste apenas de interfaces",
      "Eliminação completa de testes manuais"
    ],
    "correct": 1,
    "explanation": "Automação de testes é o uso de ferramentas e scripts para executar testes sem intervenção manual, aumentando eficiência e repetibilidade."
  },
  {
    "id": 27,
    "question": "Qual tipo de teste é mais adequado para automação?",
    "options": [
      "Testes exploratórios",
      "Testes repetitivos e estáveis",
      "Testes de usabilidade",
      "Testes que mudam frequentemente"
    ],
    "correct": 1,
    "explanation": "Testes repetitivos e estáveis são mais adequados para automação, pois proporcionam melhor retorno sobre investimento e reduzem esforço manual."
  },
  {
    "id": 28,
    "question": "Qual é uma limitação da automação de testes?",
    "options": [
      "É sempre mais rápida que teste manual",
      "Requer investimento inicial e manutenção",
      "Funciona para todos os tipos de teste",
      "Elimina a necessidade de testadores"
    ],
    "correct": 1,
    "explanation": "Automação requer investimento inicial significativo em ferramentas, scripts e treinamento, além de manutenção contínua dos scripts de teste."
  },
  {
    "id": 29,
    "question": "O que é pirâmide de testes?",
    "options": [
      "Uma ferramenta de teste",
      "Estratégia que prioriza mais testes de unidade, menos de integração e ainda menos de UI",
      "Um tipo de defeito",
      "Um modelo de processo"
    ],
    "correct": 1,
    "explanation": "A pirâmide de testes é uma estratégia que recomenda mais testes de unidade (base), menos testes de integração (meio) e ainda menos testes de UI (topo)."
  },
  {
    "id": 30,
    "question": "Por que a pirâmide de testes recomenda mais testes de unidade?",
    "options": [
      "São mais fáceis de escrever",
      "São mais rápidos, baratos e estáveis",
      "Encontram mais defeitos",
      "São mais importantes"
    ],
    "correct": 1,
    "explanation": "Testes de unidade são mais rápidos de executar, mais baratos de manter e mais estáveis (menos propensos a falsos positivos) que testes de níveis superiores."
  },
  {
    "id": 31,
    "question": "O que é teste exploratório?",
    "options": [
      "Teste baseado apenas em scripts",
      "Teste simultâneo de aprendizado, design e execução",
      "Teste automatizado",
      "Teste de performance"
    ],
    "correct": 1,
    "explanation": "Teste exploratório é uma abordagem onde aprendizado sobre o sistema, design de teste e execução acontecem simultaneamente, sem scripts predefinidos."
  },
  {
    "id": 32,
    "question": "Qual é a vantagem do teste exploratório?",
    "options": [
      "É mais rápido que teste scriptado",
      "Permite descobrir defeitos inesperados e melhorar entendimento do sistema",
      "É mais fácil de documentar",
      "Requer menos habilidade"
    ],
    "correct": 1,
    "explanation": "Teste exploratório permite descobrir defeitos inesperados que scripts predefinidos podem não encontrar e melhora o entendimento do sistema."
  },
  {
    "id": 33,
    "question": "O que é teste baseado em risco?",
    "options": [
      "Teste aleatório",
      "Priorização de testes baseada na probabilidade e impacto de falhas",
      "Teste apenas de funcionalidades críticas",
      "Teste sem planejamento"
    ],
    "correct": 1,
    "explanation": "Teste baseado em risco prioriza esforços de teste baseado na probabilidade de falha e impacto potencial de defeitos em diferentes áreas do sistema."
  },
  {
    "id": 34,
    "question": "Como identificar áreas de alto risco para teste?",
    "options": [
      "Testar tudo igualmente",
      "Analisar complexidade, criticidade, histórico de defeitos e mudanças recentes",
      "Focar apenas em funcionalidades novas",
      "Seguir ordem alfabética"
    ],
    "correct": 1,
    "explanation": "Áreas de alto risco são identificadas analisando fatores como complexidade técnica, criticidade de negócio, histórico de defeitos e mudanças recentes."
  },
  {
    "id": 35,
    "question": "O que é análise estática?",
    "options": [
      "Execução de código para encontrar defeitos",
      "Análise de código, documentos ou modelos sem executá-los",
      "Teste de performance",
      "Teste de interface"
    ],
    "correct": 1,
    "explanation": "Análise estática examina código, documentos ou modelos sem executá-los, identificando defeitos potenciais através de revisão ou ferramentas."
  },
  {
    "id": 36,
    "question": "Qual é uma vantagem da análise estática?",
    "options": [
      "Encontra defeitos de runtime",
      "Pode encontrar defeitos antes mesmo da execução do código",
      "É mais cara que teste dinâmico",
      "Substitui completamente teste dinâmico"
    ],
    "correct": 1,
    "explanation": "Análise estática pode encontrar defeitos muito cedo no ciclo de desenvolvimento, antes mesmo do código ser executável, reduzindo custos de correção."
  },
  {
    "id": 37,
    "question": "O que são revisões de código?",
    "options": [
      "Execução automatizada de testes",
      "Exame sistemático de código por pares para encontrar defeitos",
      "Compilação de código",
      "Deploy de código"
    ],
    "correct": 1,
    "explanation": "Revisões de código são exames sistemáticos de código fonte por outros desenvolvedores para encontrar defeitos, melhorar qualidade e compartilhar conhecimento."
  },
  {
    "id": 38,
    "question": "Qual é o benefício das revisões de código além de encontrar defeitos?",
    "options": [
      "Acelerar desenvolvimento",
      "Compartilhar conhecimento e melhorar habilidades da equipe",
      "Reduzir documentação",
      "Eliminar necessidade de testes"
    ],
    "correct": 1,
    "explanation": "Revisões de código promovem compartilhamento de conhecimento, melhoria de habilidades da equipe, padronização de código e mentoria."
  },
  {
    "id": 39,
    "question": "O que é integração contínua (CI)?",
    "options": [
      "Integração manual diária",
      "Prática de integrar código frequentemente com verificação automatizada",
      "Integração apenas no final do sprint",
      "Integração sem testes"
    ],
    "correct": 1,
    "explanation": "Integração contínua é uma prática onde desenvolvedores integram código frequentemente (várias vezes ao dia) com verificação automatizada através de build e testes."
  },
  {
    "id": 40,
    "question": "Qual é o benefício principal da integração contínua?",
    "options": [
      "Reduzir documentação",
      "Detectar problemas de integração rapidamente",
      "Eliminar necessidade de testes manuais",
      "Acelerar desenvolvimento individual"
    ],
    "correct": 1,
    "explanation": "CI permite detectar problemas de integração rapidamente, quando são mais fáceis e baratos de corrigir, evitando 'integration hell'."
  },
  {
    "id": 41,
    "question": "O que é entrega contínua (CD)?",
    "options": [
      "Entrega manual semanal",
      "Capacidade de entregar software de forma rápida, segura e sustentável",
      "Entrega apenas de documentação",
      "Entrega sem testes"
    ],
    "correct": 1,
    "explanation": "Entrega contínua é a capacidade de entregar software de forma rápida, segura e sustentável através de automação de build, teste e deploy."
  },
  {
    "id": 42,
    "question": "Qual é a diferença entre entrega contínua e deploy contínuo?",
    "options": [
      "São a mesma coisa",
      "Entrega contínua permite deploy a qualquer momento, deploy contínuo faz deploy automaticamente",
      "Entrega é manual, deploy é automatizado",
      "Entrega é para teste, deploy é para produção"
    ],
    "correct": 1,
    "explanation": "Entrega contínua mantém o software sempre pronto para deploy, enquanto deploy contínuo automaticamente faz deploy de toda mudança que passa nos testes."
  },
  {
    "id": 43,
    "question": "O que é DevOps?",
    "options": [
      "Uma ferramenta específica",
      "Cultura e práticas que integram desenvolvimento e operações",
      "Um tipo de teste",
      "Uma metodologia de desenvolvimento"
    ],
    "correct": 1,
    "explanation": "DevOps é uma cultura e conjunto de práticas que quebra silos entre desenvolvimento e operações, promovendo colaboração e automação."
  },
  {
    "id": 44,
    "question": "Como QA se integra com DevOps?",
    "options": [
      "QA não tem relação com DevOps",
      "Através de automação, testes contínuos e feedback rápido",
      "Apenas no final do pipeline",
      "Apenas em ambiente de produção"
    ],
    "correct": 1,
    "explanation": "QA se integra com DevOps através de automação de testes, testes contínuos no pipeline, feedback rápido e colaboração entre todas as equipes."
  },
  {
    "id": 45,
    "question": "O que são testes em produção?",
    "options": [
      "Testes que falharam em outros ambientes",
      "Técnicas para validar software em ambiente de produção real",
      "Testes apenas para bugs críticos",
      "Testes manuais em produção"
    ],
    "correct": 1,
    "explanation": "Testes em produção são técnicas para validar software em ambiente de produção real, incluindo monitoramento, canary releases e feature flags."
  },
  {
    "id": 46,
    "question": "O que é monitoramento sintético?",
    "options": [
      "Monitoramento de usuários reais",
      "Simulação automatizada de transações de usuário em produção",
      "Monitoramento de código",
      "Monitoramento de documentação"
    ],
    "correct": 1,
    "explanation": "Monitoramento sintético simula automaticamente transações de usuário em produção para detectar problemas antes que usuários reais sejam afetados."
  },
  {
    "id": 47,
    "question": "O que é teste A/B?",
    "options": [
      "Teste de duas versões diferentes para comparar performance com usuários reais",
      "Teste alfabético",
      "Teste de duas pessoas",
      "Teste de duas funcionalidades"
    ],
    "correct": 0,
    "explanation": "Teste A/B compara duas versões diferentes de um produto ou funcionalidade com usuários reais para determinar qual performa melhor."
  },
  {
    "id": 48,
    "question": "O que é canary release?",
    "options": [
      "Release completo",
      "Release gradual para um subconjunto de usuários",
      "Release apenas em teste",
      "Release manual"
    ],
    "correct": 1,
    "explanation": "Canary release é uma técnica de deploy gradual onde uma nova versão é liberada para um pequeno subconjunto de usuários antes do rollout completo."
  },
  {
    "id": 49,
    "question": "O que são feature flags?",
    "options": [
      "Bandeiras decorativas",
      "Técnica para ativar/desativar funcionalidades sem redeploy",
      "Marcadores de código",
      "Documentação de features"
    ],
    "correct": 1,
    "explanation": "Feature flags permitem ativar ou desativar funcionalidades em tempo de execução sem necessidade de novo deploy, facilitando testes e rollbacks."
  },
  {
    "id": 50,
    "question": "O que é observabilidade?",
    "options": [
      "Apenas monitoramento",
      "Capacidade de entender o estado interno do sistema através de outputs externos",
      "Apenas logs",
      "Apenas métricas"
    ],
    "correct": 1,
    "explanation": "Observabilidade é a capacidade de entender o estado interno de um sistema através de seus outputs externos (logs, métricas, traces)."
  },
  {
    "id": 51,
    "question": "Quais são os três pilares da observabilidade?",
    "options": [
      "Frontend, backend, banco",
      "Logs, métricas e traces",
      "Dev, test, prod",
      "Manual, automatizado, exploratório"
    ],
    "correct": 1,
    "explanation": "Os três pilares da observabilidade são: logs (eventos discretos), métricas (dados numéricos agregados) e traces (jornada de requisições)."
  },
  {
    "id": 52,
    "question": "O que é teste de performance?",
    "options": [
      "Teste de funcionalidades",
      "Avaliação de velocidade, estabilidade e escalabilidade sob diferentes cargas",
      "Teste de interface",
      "Teste de segurança"
    ],
    "correct": 1,
    "explanation": "Teste de performance avalia características como velocidade, estabilidade, escalabilidade e uso de recursos do sistema sob diferentes condições de carga."
  },
  {
    "id": 53,
    "question": "Qual é a diferença entre teste de carga e teste de estresse?",
    "options": [
      "São a mesma coisa",
      "Carga testa condições normais, estresse testa além dos limites",
      "Carga é automatizado, estresse é manual",
      "Carga é para web, estresse é para mobile"
    ],
    "correct": 1,
    "explanation": "Teste de carga verifica comportamento sob condições normais esperadas, enquanto teste de estresse testa além dos limites normais para encontrar pontos de falha."
  },
  {
    "id": 54,
    "question": "O que é teste de volume?",
    "options": [
      "Teste de áudio",
      "Teste com grandes quantidades de dados",
      "Teste de interface",
      "Teste de rede"
    ],
    "correct": 1,
    "explanation": "Teste de volume verifica o comportamento do sistema quando processando grandes quantidades de dados para identificar problemas de capacidade."
  },
  {
    "id": 55,
    "question": "O que é teste de spike?",
    "options": [
      "Teste com aumento súbito e dramático de carga",
      "Teste de segurança",
      "Teste de funcionalidade",
      "Teste de interface"
    ],
    "correct": 0,
    "explanation": "Teste de spike verifica como o sistema se comporta com aumentos súbitos e dramáticos de carga, simulando picos de tráfego inesperados."
  },
  {
    "id": 56,
    "question": "O que é teste de usabilidade?",
    "options": [
      "Teste de performance",
      "Avaliação da facilidade de uso e experiência do usuário",
      "Teste de segurança",
      "Teste de código"
    ],
    "correct": 1,
    "explanation": "Teste de usabilidade avalia quão fácil, eficiente e satisfatório é para usuários reais interagirem com o sistema para alcançar seus objetivos."
  },
  {
    "id": 57,
    "question": "Quais aspectos são avaliados em teste de usabilidade?",
    "options": [
      "Apenas velocidade",
      "Eficácia, eficiência e satisfação do usuário",
      "Apenas bugs",
      "Apenas design visual"
    ],
    "correct": 1,
    "explanation": "Teste de usabilidade avalia eficácia (usuário consegue completar tarefas), eficiência (com que facilidade) e satisfação (experiência subjetiva)."
  },
  {
    "id": 58,
    "question": "O que é teste de acessibilidade?",
    "options": [
      "Teste de acesso ao sistema",
      "Verificação se o software é usável por pessoas com deficiências",
      "Teste de login",
      "Teste de permissões"
    ],
    "correct": 1,
    "explanation": "Teste de acessibilidade verifica se o software pode ser usado por pessoas com diferentes tipos de deficiências, seguindo padrões como WCAG."
  },
  {
    "id": 59,
    "question": "O que é WCAG?",
    "options": [
      "Uma ferramenta de teste",
      "Web Content Accessibility Guidelines - diretrizes de acessibilidade web",
      "Um tipo de defeito",
      "Uma metodologia de desenvolvimento"
    ],
    "correct": 1,
    "explanation": "WCAG (Web Content Accessibility Guidelines) são diretrizes internacionais para tornar conteúdo web acessível a pessoas com deficiências."
  },
  {
    "id": 60,
    "question": "O que é teste de segurança?",
    "options": [
      "Teste de performance",
      "Verificação de vulnerabilidades e proteção contra ameaças",
      "Teste de funcionalidades",
      "Teste de interface"
    ],
    "correct": 1,
    "explanation": "Teste de segurança verifica vulnerabilidades, proteção de dados, autenticação, autorização e resistência a ataques maliciosos."
  },
  {
    "id": 61,
    "question": "O que é OWASP Top 10?",
    "options": [
      "Lista das 10 melhores ferramentas de teste",
      "Lista das 10 principais vulnerabilidades de segurança web",
      "Lista dos 10 melhores testadores",
      "Lista das 10 melhores práticas de desenvolvimento"
    ],
    "correct": 1,
    "explanation": "OWASP Top 10 é uma lista das 10 principais vulnerabilidades de segurança em aplicações web, atualizada regularmente pela comunidade OWASP."
  },
  {
    "id": 62,
    "question": "O que é teste de compatibilidade?",
    "options": [
      "Teste de performance",
      "Verificação se o software funciona em diferentes ambientes, browsers e dispositivos",
      "Teste de segurança",
      "Teste de usabilidade"
    ],
    "correct": 1,
    "explanation": "Teste de compatibilidade verifica se o software funciona corretamente em diferentes sistemas operacionais, browsers, dispositivos e versões."
  },
  {
    "id": 63,
    "question": "O que é teste de API?",
    "options": [
      "Teste de interface gráfica",
      "Teste da camada de comunicação entre sistemas",
      "Teste de banco de dados",
      "Teste de documentação"
    ],
    "correct": 1,
    "explanation": "Teste de API verifica a comunicação, funcionalidade, confiabilidade e performance das interfaces de programação de aplicações."
  },
  {
    "id": 64,
    "question": "Quais aspectos são testados em APIs?",
    "options": [
      "Apenas funcionalidade",
      "Funcionalidade, performance, segurança e contratos de dados",
      "Apenas performance",
      "Apenas segurança"
    ],
    "correct": 1,
    "explanation": "Teste de API abrange funcionalidade (respostas corretas), performance (tempo de resposta), segurança (autenticação/autorização) e contratos de dados."
  },
  {
    "id": 65,
    "question": "O que são testes end-to-end (E2E)?",
    "options": [
      "Testes de unidade",
      "Testes que verificam fluxos completos do sistema do início ao fim",
      "Testes de código",
      "Testes de documentação"
    ],
    "correct": 1,
    "explanation": "Testes E2E verificam fluxos completos do sistema, desde a interface do usuário até o banco de dados, simulando cenários reais de uso."
  },
  {
    "id": 66,
    "question": "Quando usar testes E2E?",
    "options": [
      "Para todos os cenários possíveis",
      "Para fluxos críticos de negócio e cenários de alto valor",
      "Apenas para testes manuais",
      "Apenas no final do projeto"
    ],
    "correct": 1,
    "explanation": "Testes E2E devem ser usados para fluxos críticos de negócio e cenários de alto valor, pois são mais caros e demorados que outros tipos de teste."
  },
  {
    "id": 67,
    "question": "O que é BDD (Behavior Driven Development)?",
    "options": [
      "Uma linguagem de programação",
      "Abordagem que foca na definição do comportamento esperado através de exemplos",
      "Uma ferramenta de teste",
      "Um tipo de defeito"
    ],
    "correct": 1,
    "explanation": "BDD é uma abordagem que foca na definição do comportamento esperado do software através de exemplos em linguagem natural, promovendo colaboração."
  },
  {
    "id": 68,
    "question": "O que é Gherkin?",
    "options": [
      "Uma ferramenta de automação",
      "Linguagem para escrever cenários de teste em formato legível",
      "Um tipo de defeito",
      "Uma metodologia de desenvolvimento"
    ],
    "correct": 1,
    "explanation": "Gherkin é uma linguagem de domínio específico usada para escrever cenários de teste em formato legível por humanos no contexto de BDD."
  },
  {
    "id": 69,
    "question": "Qual é a estrutura básica de um cenário Gherkin?",
    "options": [
      "Start-Process-End",
      "Given-When-Then",
      "Setup-Execute-Verify",
      "Input-Process-Output"
    ],
    "correct": 1,
    "explanation": "A estrutura básica de Gherkin é Given (contexto), When (ação), Then (resultado esperado), que descreve cenários de forma clara e estruturada."
  },
  {
    "id": 70,
    "question": "O que é TDD (Test Driven Development)?",
    "options": [
      "Escrever código antes dos testes",
      "Escrever testes antes do código de produção",
      "Uma ferramenta de automação",
      "Um tipo de teste"
    ],
    "correct": 1,
    "explanation": "TDD é uma prática onde os testes são escritos antes do código de produção, seguindo o ciclo Red (teste falha) - Green (código passa) - Refactor."
  },
  {
    "id": 71,
    "question": "Qual é o ciclo do TDD?",
    "options": [
      "Code-Test-Deploy",
      "Red-Green-Refactor",
      "Plan-Do-Check",
      "Build-Test-Release"
    ],
    "correct": 1,
    "explanation": "O ciclo TDD é Red (escrever teste que falha), Green (escrever código mínimo para passar), Refactor (melhorar código mantendo testes passando)."
  },
  {
    "id": 72,
    "question": "Qual é o benefício principal do TDD?",
    "options": [
      "Código mais rápido",
      "Design emergente e alta cobertura de testes",
      "Menos documentação",
      "Desenvolvimento mais rápido"
    ],
    "correct": 1,
    "explanation": "TDD promove design emergente (arquitetura evolui naturalmente), alta cobertura de testes e código mais testável e modular."
  },
  {
    "id": 73,
    "question": "O que é refactoring?",
    "options": [
      "Adicionar novas funcionalidades",
      "Melhorar estrutura do código sem alterar comportamento externo",
      "Corrigir bugs",
      "Escrever documentação"
    ],
    "correct": 1,
    "explanation": "Refactoring é o processo de melhorar a estrutura interna do código sem alterar seu comportamento externo, tornando-o mais limpo e manutenível."
  },
  {
    "id": 74,
    "question": "Por que testes são importantes para refactoring?",
    "options": [
      "Não são importantes",
      "Garantem que o comportamento não muda durante a reestruturação",
      "Aceleram o processo",
      "Reduzem o trabalho"
    ],
    "correct": 1,
    "explanation": "Testes são essenciais para refactoring pois garantem que o comportamento externo do código não muda durante a reestruturação interna."
  },
  {
    "id": 75,
    "question": "O que é debt técnico?",
    "options": [
      "Dinheiro devido por ferramentas",
      "Custo futuro de retrabalho causado por soluções rápidas",
      "Tempo gasto em reuniões",
      "Documentação em atraso"
    ],
    "correct": 1,
    "explanation": "Débito técnico é o custo futuro de retrabalho causado por escolher soluções rápidas e fáceis agora em vez de usar abordagens melhores que levariam mais tempo."
  },
  {
    "id": 76,
    "question": "Como testes ajudam a gerenciar débito técnico?",
    "options": [
      "Eliminam completamente o débito",
      "Permitem refactoring seguro e detectam regressões",
      "Não têm relação com débito técnico",
      "Aumentam o débito técnico"
    ],
    "correct": 1,
    "explanation": "Testes permitem refactoring seguro para pagar débito técnico e detectam regressões quando mudanças são feitas para melhorar a qualidade do código."
  },
  {
    "id": 77,
    "question": "O que é pair testing?",
    "options": [
      "Teste automatizado",
      "Dois testadores trabalhando juntos no mesmo teste",
      "Teste de duas funcionalidades",
      "Teste em dupla de ambientes"
    ],
    "correct": 1,
    "explanation": "Pair testing é quando dois testadores trabalham juntos no mesmo teste, combinando diferentes perspectivas e habilidades para melhor cobertura."
  },
  {
    "id": 78,
    "question": "O que é mob testing?",
    "options": [
      "Teste por multidão",
      "Toda a equipe trabalhando juntas em teste",
      "Teste automatizado em massa",
      "Teste de aplicações móveis"
    ],
    "correct": 1,
    "explanation": "Mob testing é quando toda a equipe (desenvolvedores, testadores, analistas) trabalha junta em atividades de teste, promovendo colaboração e aprendizado."
  },
  {
    "id": 79,
    "question": "O que é three amigos?",
    "options": [
      "Três testadores trabalhando juntos",
      "Colaboração entre desenvolvedor, testador e analista de negócio",
      "Três ambientes de teste",
      "Três tipos de teste"
    ],
    "correct": 1,
    "explanation": "Three amigos é a colaboração entre desenvolvedor, testador e analista de negócio para definir requisitos, critérios de aceitação e abordagem de teste."
  },
  {
    "id": 80,
    "question": "Qual é o objetivo do three amigos?",
    "options": [
      "Acelerar desenvolvimento",
      "Garantir entendimento comum e reduzir ambiguidades",
      "Reduzir número de pessoas envolvidas",
      "Eliminar documentação"
    ],
    "correct": 1,
    "explanation": "O objetivo é garantir entendimento comum entre as perspectivas de negócio, desenvolvimento e teste, reduzindo ambiguidades e melhorando qualidade."
  },
  {
    "id": 81,
    "question": "O que é definition of done?",
    "options": [
      "Quando o código está escrito",
      "Critérios que devem ser atendidos para considerar uma funcionalidade completa",
      "Quando os testes passam",
      "Quando o deploy é feito"
    ],
    "correct": 1,
    "explanation": "Definition of Done é um conjunto de critérios que devem ser atendidos para considerar uma funcionalidade ou user story verdadeiramente completa."
  },
  {
    "id": 82,
    "question": "O que tipicamente inclui uma definition of done?",
    "options": [
      "Apenas código escrito",
      "Código, testes, revisão, documentação e critérios de aceitação atendidos",
      "Apenas testes passando",
      "Apenas deploy realizado"
    ],
    "correct": 1,
    "explanation": "Definition of Done tipicamente inclui código escrito e revisado, testes criados e passando, documentação atualizada e critérios de aceitação atendidos."
  },
  {
    "id": 83,
    "question": "O que é acceptance criteria?",
    "options": [
      "Critérios para aceitar testadores",
      "Condições que devem ser atendidas para aceitar uma funcionalidade",
      "Critérios para aceitar bugs",
      "Critérios para aceitar ferramentas"
    ],
    "correct": 1,
    "explanation": "Acceptance criteria são condições específicas que devem ser atendidas para que uma funcionalidade seja aceita como completa e funcionando corretamente."
  },
  {
    "id": 84,
    "question": "Quem deve definir acceptance criteria?",
    "options": [
      "Apenas desenvolvedores",
      "Product owner em colaboração com a equipe",
      "Apenas testadores",
      "Apenas gerentes"
    ],
    "correct": 1,
    "explanation": "Acceptance criteria devem ser definidos pelo product owner em colaboração com desenvolvedores, testadores e outros stakeholders relevantes."
  },
  {
    "id": 85,
    "question": "O que é user story?",
    "options": [
      "História pessoal do usuário",
      "Descrição informal de funcionalidade do ponto de vista do usuário",
      "Biografia do usuário",
      "Manual do usuário"
    ],
    "correct": 1,
    "explanation": "User story é uma descrição informal e concisa de uma funcionalidade escrita do ponto de vista do usuário final, focando no valor de negócio."
  },
  {
    "id": 86,
    "question": "Qual é o formato típico de uma user story?",
    "options": [
      "Como [papel], eu quero [funcionalidade] para que [benefício]",
      "O sistema deve fazer X",
      "Implementar funcionalidade Y",
      "Corrigir bug Z"
    ],
    "correct": 0,
    "explanation": "O formato típico é 'Como [papel], eu quero [funcionalidade] para que [benefício]', focando no usuário, ação desejada e valor obtido."
  },
  {
    "id": 87,
    "question": "O que significa INVEST em user stories?",
    "options": [
      "Investimento financeiro",
      "Independent, Negotiable, Valuable, Estimable, Small, Testable",
      "Critérios de performance",
      "Metodologia de desenvolvimento"
    ],
    "correct": 1,
    "explanation": "INVEST são critérios para boas user stories: Independent (independente), Negotiable (negociável), Valuable (valiosa), Estimable (estimável), Small (pequena), Testable (testável)."
  },
  {
    "id": 88,
    "question": "O que é epic em metodologias ágeis?",
    "options": [
      "Uma história muito longa",
      "Grande funcionalidade que pode ser dividida em user stories menores",
      "Um tipo de defeito",
      "Uma ferramenta de gestão"
    ],
    "correct": 1,
    "explanation": "Epic é uma grande funcionalidade ou requisito que é muito grande para ser implementado em uma sprint e precisa ser dividido em user stories menores."
  },
  {
    "id": 89,
    "question": "O que é spike em desenvolvimento ágil?",
    "options": [
      "Aumento súbito de trabalho",
      "Investigação time-boxed para reduzir incertezas técnicas",
      "Tipo de teste",
      "Reunião de equipe"
    ],
    "correct": 1,
    "explanation": "Spike é uma investigação time-boxed para reduzir incertezas técnicas ou de requisitos, geralmente resultando em conhecimento em vez de código de produção."
  },
  {
    "id": 90,
    "question": "O que é velocity em Scrum?",
    "options": [
      "Velocidade de execução de código",
      "Medida de quanto trabalho a equipe consegue completar por sprint",
      "Velocidade de internet",
      "Tempo de resposta do sistema"
    ],
    "correct": 1,
    "explanation": "Velocity é uma medida de quanto trabalho (geralmente em story points) uma equipe consegue completar consistentemente por sprint."
  },
  {
    "id": 91,
    "question": "Para que serve velocity?",
    "options": [
      "Comparar equipes",
      "Planejamento e previsão de entregas futuras",
      "Avaliar performance individual",
      "Definir salários"
    ],
    "correct": 1,
    "explanation": "Velocity serve para planejamento e previsão de entregas futuras, ajudando a equipe a entender sua capacidade e fazer compromissos realistas."
  },
  {
    "id": 92,
    "question": "O que é burndown chart?",
    "options": [
      "Gráfico de temperatura",
      "Gráfico que mostra trabalho restante ao longo do tempo",
      "Gráfico de performance",
      "Gráfico de custos"
    ],
    "correct": 1,
    "explanation": "Burndown chart é um gráfico que mostra a quantidade de trabalho restante (eixo Y) ao longo do tempo (eixo X) durante uma sprint ou release."
  },
  {
    "id": 93,
    "question": "O que indica um burndown chart ideal?",
    "options": [
      "Linha horizontal",
      "Linha descendente constante até zero",
      "Linha ascendente",
      "Linha irregular"
    ],
    "correct": 1,
    "explanation": "Um burndown chart ideal mostra uma linha descendente constante, indicando que o trabalho está sendo completado de forma consistente ao longo da sprint."
  },
  {
    "id": 94,
    "question": "O que é retrospectiva em Scrum?",
    "options": [
      "Revisão de código",
      "Reunião para refletir sobre o processo e identificar melhorias",
      "Apresentação para stakeholders",
      "Planejamento da próxima sprint"
    ],
    "correct": 1,
    "explanation": "Retrospectiva é uma reunião onde a equipe reflete sobre o processo de trabalho da sprint anterior e identifica melhorias para implementar."
  },
  {
    "id": 95,
    "question": "Qual é o objetivo principal da retrospectiva?",
    "options": [
      "Culpar pessoas por problemas",
      "Melhoria contínua do processo de trabalho da equipe",
      "Reportar status para gerência",
      "Planejar funcionalidades"
    ],
    "correct": 1,
    "explanation": "O objetivo principal é a melhoria contínua do processo de trabalho da equipe, identificando o que funcionou bem e o que pode ser melhorado."
  },
  {
    "id": 96,
    "question": "O que é daily standup/scrum?",
    "options": [
      "Reunião de planejamento",
      "Reunião diária rápida para sincronização da equipe",
      "Reunião com stakeholders",
      "Reunião de retrospectiva"
    ],
    "correct": 1,
    "explanation": "Daily standup é uma reunião diária rápida (15 minutos) onde a equipe se sincroniza sobre progresso, planos e impedimentos."
  },
  {
    "id": 97,
    "question": "Quais são as três perguntas típicas do daily standup?",
    "options": [
      "Quem, o que, quando",
      "O que fiz ontem, o que farei hoje, que impedimentos tenho",
      "Por que, como, onde",
      "Quanto, quando, quem"
    ],
    "correct": 1,
    "explanation": "As três perguntas são: O que fiz desde o último standup? O que farei até o próximo? Que impedimentos estou enfrentando?"
  },
  {
    "id": 98,
    "question": "O que é sprint review?",
    "options": [
      "Revisão de código",
      "Demonstração do trabalho completado para stakeholders",
      "Reunião de retrospectiva",
      "Planejamento da sprint"
    ],
    "correct": 1,
    "explanation": "Sprint review é uma reunião onde a equipe demonstra o trabalho completado durante a sprint para stakeholders e coleta feedback."
  },
  {
    "id": 99,
    "question": "Qual é a diferença entre sprint review e retrospectiva?",
    "options": [
      "São a mesma coisa",
      "Review foca no produto, retrospectiva foca no processo",
      "Review é interna, retrospectiva é com stakeholders",
      "Review é opcional, retrospectiva é obrigatória"
    ],
    "correct": 1,
    "explanation": "Sprint review foca no produto desenvolvido e feedback dos stakeholders, enquanto retrospectiva foca no processo de trabalho da equipe."
  },
  {
    "id": 100,
    "question": "Qual é o papel do testador em uma equipe ágil?",
    "options": [
      "Apenas executar testes no final",
      "Colaborar durante todo o ciclo, desde requisitos até entrega",
      "Apenas escrever casos de teste",
      "Apenas encontrar bugs"
    ],
    "correct": 1,
    "explanation": "O testador em equipe ágil colabora durante todo o ciclo: ajuda na definição de requisitos, critérios de aceitação, automação, e garante qualidade contínua."
  }
]



